

## Exercise 1.9

Each of the following two functions defines a method for adding two positive integers in terms of the functions `inc`, which increments its argument by 1, and `dec`, which decrements its argument by 1.

```js
function plus(a, b) {
  return a === 0 ? b : inc(plus(dec(a), b));
}

function plus(a, b) {
  return a === 0 ? b : plus(dec(a), inc(b));
}

```

Using the **substitution model**, illustrate the process generated by each function in evaluating `plus(4, 5)`. Are these processes **iterative** or **recursive**?

----------

### 1. Recursive Process (Deferred Operations)

```js
function plus(a, b) {
  return a === 0 ? b : inc(plus(dec(a), b));
}

```

#### Substitution steps

```text
plus(4, 5)
→ inc(plus(3, 5))
→ inc(inc(plus(2, 5)))
→ inc(inc(inc(plus(1, 5))))
→ inc(inc(inc(inc(plus(0, 5)))))
→ inc(inc(inc(inc(5))))
→ inc(inc(inc(6)))
→ inc(inc(7))
→ inc(8)
→ 9

```

### Important point

Look at the stack of **pending `inc` calls**:

```text
inc(inc(inc(inc(5))))

```

This stack must be remembered somewhere.

**Characteristics**:

-   Linear **recursive** process
    
-   Builds **deferred operations** (`inc` calls)
    
-   Call stack grows with `a`
    
-   Memory usage increases with input size
    

----------

### 2. Iterative Process (No Deferred Work)

```js
function plus(a, b) {
  return a === 0 ? b : plus(dec(a), inc(b));
}

```

### Substitution steps

```text
plus(4, 5)
→ plus(3, 6)
→ plus(2, 7)
→ plus(1, 8)
→ plus(0, 9)
→ 9

```

### Important point

There is **nothing left to do after the recursive call returns**.

That is the definition of an **iterative process**.

**Characteristics**:

-   Iterative process
    
-   Constant memory usage
    
-   No deferred work
    
-   Tail call