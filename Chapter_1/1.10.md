
### Exercise 1.10 — Ackermann’s Function (SICP JS)

#### Given function

```js
function A(x, y) {
  return y === 0
    ? 0
    : x === 0
    ? 2 * y
    : y === 1
    ? 2
    : A(x - 1, A(x, y - 1));
}
```

This function is defined using **nested recursion** and multiple **base cases**.

---

#### Evaluating the given expressions

---

#### 1. `A(1, 10)`

For `x = 1`, the recursive rule becomes:

```
A(1, y) = A(0, A(1, y − 1)) = 2 × A(1, y − 1)
```

So the process is repeated doubling:

```
A(1,10)
= 2 × A(1,9)
= 2 × (2 × A(1,8))
= 2 × (2 × (2 × A(1,7)))
...
= 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2
```

**Result:**

```
A(1,10) = 2¹⁰ = 1024
```

---

#### 2. `A(2, 4)`

For `x = 2`, the recursive rule is:

```
A(2, y) = A(1, A(2, y − 1))
```

Step-by-step:

```
A(2,4)
= A(1, A(2,3))
= A(1, A(1, A(2,2)))
= A(1, A(1, A(1, A(2,1))))
```

Base case:

```
A(2,1) = 2
```

Substitute back:

```
A(1, A(1, A(1, 2)))
= A(1, A(1, 4))
= A(1, 16)
```

From above:

```
A(1,16) = 2¹⁶ = 65536
```

**Result:**

```
A(2,4) = 65536
```

---

#### 3. `A(3, 3)`

For `x = 3`:

```
A(3, y) = A(2, A(3, y − 1))
```

Step-by-step:

```
A(3,3)
= A(2, A(3,2))
= A(2, A(2, A(3,1)))
```

Base case:

```
A(3,1) = 2
```

So:

```
A(2, A(2,2))
```

From earlier:

```
A(2,2) = 4
```

Thus:

```
A(2,4) = 65536
```

**Result:**

```
A(3,3) = 65536
```

---

#### Functions derived from `A`

---

#### Function `f`

```js
function f(n) {
  return A(0, n);
}
```

From the base rule:

```
A(0, n) = 2n
```

**Definition:**

```
f(n) = 2n
```

---

#### Function `g`

```js
function g(n) {
  return A(1, n);
}
```

We observed:

```
A(1, n) = 2 × A(1, n − 1)
A(1, 1) = 2
```

So:

**Definition:**

```
g(n) = 2ⁿ
```

---

#### Function `h`

```js
function h(n) {
  return A(2, n);
}
```

From the recursive structure:

```
A(2, n) = A(1, A(2, n − 1))
```

Which means:

> each step raises 2 to the power of the previous result

Values:

```
h(1) = 2
h(2) = 2² = 4
h(3) = 2⁴ = 16
h(4) = 2¹⁶ = 65536
```

**Definition:**

```
h(n) = 2^(2^(2^(...)))   // n times
```

(A power tower of 2s of height `n`)

---

#### Final answers (concise form)

```
A(1,10) = 1024
A(2,4)  = 65536
A(3,3)  = 65536

f(n) = 2n
g(n) = 2ⁿ
h(n) = power tower of 2s (height n)
```

---

#### Simple insights

* Changing **which argument recurses** changes the **entire growth behavior**
* `f` never really recurses → simple arithmetic
* `g` recurses linearly → exponential growth
* `h` nests recursion inside recursion → explosive growth

Small structural differences → massive computational consequences.

---

#### What was the real point of this exercise?

Not math. Not numbers.

The point was to show:

1. **Recursion shape matters more than recursion itself**
2. Base cases are not “details” — they define the universe
3. Nested recursion causes growth that quickly becomes infeasible
4. You must reason about **process**, not just code

> Two functions can look similar
> and differ by *orders of magnitude* in behavior.

This is why engineers care deeply about:

* recursion depth
* evaluation order
* growth rates


